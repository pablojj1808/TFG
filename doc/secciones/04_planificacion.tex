\chapter{Planificación}
En este capítulo detallaré todo lo relativo a la planificación y estimación del proyecto. 

\section{Metodología utilizada}
Desde que se empiezan a programar los primeros ordenadores en la historia, la programación siempre ha sido 
minguneada y considerada bastante lejos de una actividad científica. Todo empezó a cambiar cuando los scipts
permitían realizar cálculos como ninguna otra herramienta hasta el momento. Fue la matemática Margaret Hamilton 
quien planteó por primera vez que los sistemas informáticos tenían que integrar tres componentes: hardware, 
software y los usuarios que los iban a usar. Fue Margaret Hamiltonen, cuando se produce lo que conocemos como 
crisis del software en 1968 quien acuñó en la \textit{NATO Software Engineering Conference} el termino Ingeniería
al proceso de creación de software. En ese momento donde parecía que crear software duradero y escalable en el tiempo 
era misión imposible hizo que se invirtiera en investigación y se construyera conocimiento. Este conocimiento es lo que hoy 
llamamos Ingeniería de Software: herramientas, técnicas de especificación y diseño que nos permiten especificar, 
desarrollar, validar y evolucionar como en cualquier otra ingeniería.

Las metodologías ágiles presentan una forma distinta de trabajar y organizarse, adaptándose a las condiciones
cambiantes que puedan surgir, aprovechando estos cambios para obtener ventajas. Con este tipo de metodologías 
podemos dividir el trabajo en pequeñas piezas de manera que podemos ir realizándolos de forma incremental.

Se ha barajado utilizar una de las dos metodologías más empleadas en la industria: Scrum y eXtreme Programming. 
eXtreme programming ha sido descartada por la imposibilidad de aplicación en términos de tiempo y recursos humanos. 
Los roles y artefactos exigidos por esta metodología son indiscutiblemente para un equipo de desarrollo segmentado. 
Sin embargo y en comparación con Scrum es una metodología muy enfocada en el proceso de desarrollo. Obliga a 
desarrollar guiándose de pruebas, a programar en parejas y asegurar la calidad del código en todas las etapas.

Scrum en cambio se muestra más flexible. En el año 2001 que K. Schwaber y Mike Beedle publican el
primer libro sobre Scrum\cite{agile_book}: "Agile Software Development with Scrum" esta metodología se ha convertido en la
más utilizada para el desarrollo de software. Siendo precisos y prudentes tampoco es posible aplicar 
propiamente dicho Scrum en este proyecto... fundamentalmente por ser una persona a cargo de todo el proceso.

Por tanto, me he permitido crear mi propia metodología de desarrollo basándome en los tres valores fundamentales 
que ofrecen estas tecnologías:
\begin{itemize}
    \item \textbf{Transparencia}: en todo momento se ha de conocer en qué se está trabajando, que problemas se está teniendo y/o si 
    existe algún bloqueo asociado.
    \item \textbf{Inspección}: se ha de inspeccionar y no perder de vista el progreso para conseguir el objetivo. La 
    trazabilidad del trabajo nos la ofrece el SCV (source control versioning) en nuestro caso GitHub con incorporación
    de funcionalidad por pull request.
    \item \textbf{Adaptación}: poder reaccionar a tiempo a los cambios requeridos por los stakeholders.
\end{itemize}

Una buena forma de cumplir las características citadas anteriormente, es realizar el desarrollo guiado por pruebas, 
lo que se conoce por TDD, \textit{Test Driven Development}. Al emplear esta metodología garantizamos la calidad 
de lo programado, trasladamos los requisitos a las pruebas de forma que se convierten en la más fiable documentación.
Además tener una gran cobertura de código testeado nos permite poder refactorizar con asiduedad y garantizarnos 
no generar mucha deuda técnica.
Como se ha comentado en otro capítulo de esta memoria, este trabajo quiere prestarle especial atención al 
automatizaje de tareas y trabajos de infraestructura, la realización de un sistema que se integre continuamente 
(CI) hace que se proteja siempre el PMV ya que es requisito indispensable para seguir añadiendo funcionalidad 
que los test pasen lo que significa que se siguen manteniendo los requisitos anteriores al añadir nueva 
funcionalidad.

\section{Herramientas}
Para el contribuir con la segunda característica introspectiva citada anteriormente, necesitmaos no perder 
de vista el progreso para conseguir el objetivo. Se ha recurrido a utlizar un sistema de control de versiones, 
sin discusión alguna GIT ha sido la herramienta seleccionada. Se hace necesario una forja donde respaldar nuestro 
código, GitHub ha sido la opción seleccionada para alojar el código y tener un registro de las issues y Pull Request. Estas
características también las pueden servicios como GitLab. Pero las características premium de GitHub que ofrece una cuenta
universitaria como los tableros Kanban, integración continua con GitHub Actions...

Haciendo uso de esta herramienta, de cada historia de usuario se han extraído issues o tareas a realizar. Los
incrementos se han ido realizando por medio de Pull Request y cada una de estas lleva enlazada una o varias
issues. Para tener una visión general del estado del proyecto se ha usado Projects.

\section{Temporización}
[TODO: Añadir diagrama de Gantt]

\section{Estimación de costes}
A partir de la información anterior en cuanto al tiempo invertido en el proyecto y en vista de los elementos necesarios
para llevarlo a cabo podemos detallar los costes asociados que tendría la elaboración del proyecto.

\begin{itemize}
    \item Nómina para el ingeniero junior.
    \item MacBook Pro [amortizado 5 años]: 240€
    \item Recursos software utilizados han sido gratuitos.
    \item Recursos de despliegues han sido gratuitos.
\end{itemize}